diff --git a/Wrapping/PythonCore/vtkPythonArgs.cxx b/Wrapping/PythonCore/vtkPythonArgs.cxx
index 9e24d21f587a73bca48ecf9f539b6e13558eb550..cf0cb6d7032f7867009dbaac563a1d9dfc0b9736 100644
--- a/Wrapping/PythonCore/vtkPythonArgs.cxx
+++ b/Wrapping/PythonCore/vtkPythonArgs.cxx
@@ -90,14 +90,48 @@ bool vtkPythonGetUnsignedLongLongValue(PyObject *o, T &a)
 }
 
 
-template <class T> inline
-bool vtkPythonGetStringValue(PyObject *o, T *&a, const char *exctext)
+Py_ssize_t vtkPythonGetStringSize(PyObject *o)
+{
+  if (PyBytes_Check(o))
+  {
+    return PyBytes_GET_SIZE(o);
+  }
+  else if (PyByteArray_Check(o))
+  {
+    return PyByteArray_GET_SIZE(o);
+  }
+#ifdef Py_USING_UNICODE
+  else if (PyUnicode_Check(o))
+  {
+#if PY_VERSION_HEX >= 0x03030000
+    Py_ssize_t size;
+    PyUnicode_AsUTF8AndSize(o, &size);
+    return size;
+#else
+    PyObject *s = _PyUnicode_AsDefaultEncodedString(o, nullptr);
+    if (s)
+    {
+      return PyBytes_GET_SIZE(s);
+    }
+#endif
+  }
+#endif
+  return 0;
+}
+
+
+bool vtkPythonGetStringValue(PyObject *o, const char *&a, const char *exctext)
 {
   if (PyBytes_Check(o))
   {
     a = PyBytes_AS_STRING(o);
     return true;
   }
+  else if (PyByteArray_Check(o))
+  {
+    a = PyByteArray_AS_STRING(o);
+    return true;
+  }
 #ifdef Py_USING_UNICODE
   else if (PyUnicode_Check(o))
   {
@@ -112,12 +146,19 @@ bool vtkPythonGetStringValue(PyObject *o, T *&a, const char *exctext)
       return true;
     }
 
-    exctext = "(unicode conversion error)";
+    if (exctext)
+    {
+      // set a more specific error message
+      exctext = "(unicode conversion error)";
+    }
 #endif
   }
 #endif
 
-  PyErr_SetString(PyExc_TypeError, exctext);
+  if (exctext)
+  {
+    PyErr_SetString(PyExc_TypeError, exctext);
+  }
   return false;
 }
 
@@ -292,7 +333,6 @@ bool vtkPythonGetValue(
   return r;
 }
 
-
 inline
 bool vtkPythonGetValue(PyObject *o, const char *&a)
 {
@@ -302,15 +342,6 @@ bool vtkPythonGetValue(PyObject *o, const char *&a)
           vtkPythonGetStringValue(o, a, "string or None required"));
 }
 
-inline
-bool vtkPythonGetValue(PyObject *o, char *&a)
-{
-  a = nullptr;
-
-  return (o == Py_None ||
-          vtkPythonGetStringValue(o, a, "string or None required"));
-}
-
 inline
 bool vtkPythonGetValue(PyObject *o, std::string &a)
 {
@@ -575,6 +606,53 @@ bool vtkPythonGetArray(PyObject *o, T *a, int n)
   return true;
 }
 
+inline bool vtkPythonGetArray(PyObject *o, char *a, int n)
+{
+  if (a)
+  {
+    Py_ssize_t m = n;
+    const char *b;
+
+    if (vtkPythonGetStringValue(o, b, nullptr))
+    {
+      m = vtkPythonGetStringSize(o);
+      if (m == n)
+      {
+        for (int i = 0; i < n; i++)
+        {
+          a[i] = b[i];
+        }
+        // terminate so it can be used as a C string
+        a[n] = '\0';
+        return true;
+      }
+    }
+    else if (PySequence_Check(o))
+    {
+      m = PySequence_Size(o);
+      if (m == n)
+      {
+        bool r = true;
+        for (int i = 0; i < n && r; i++)
+        {
+          r = false;
+          PyObject *s = PySequence_GetItem(o, i);
+          if (s && vtkPythonGetValue(s, a[i]))
+          {
+            Py_DECREF(s);
+            r = true;
+          }
+        }
+        return r;
+      }
+    }
+
+    return vtkPythonSequenceError(o, n, m);
+  }
+
+  return true;
+}
+
 //--------------------------------------------------------------------
 // Method for setting an n-dimensional C++ arrays from a Python sequence.
 
@@ -708,6 +786,51 @@ bool vtkPythonSetArray(PyObject *o, const T *a, int n)
   return true;
 }
 
+inline bool vtkPythonSetArray(PyObject *o, const char *a, int n)
+{
+  if (a)
+  {
+    Py_ssize_t m = n;
+
+    if (PyByteArray_Check(o))
+    {
+      m = PyByteArray_GET_SIZE(o);
+      if (m == n)
+      {
+        char *b = PyByteArray_AS_STRING(o);
+        for (int i = 0; i < n; i++)
+        {
+          b[i] = a[i];
+        }
+        return true;
+      }
+    }
+    else if (PySequence_Check(o))
+    {
+      m = PySequence_Size(o);
+      if (m == n)
+      {
+        bool r = true;
+        for (int i = 0; i < n && r; i++)
+        {
+          r = false;
+          PyObject *s = vtkPythonArgs::BuildValue(a[i]);
+          if (s)
+          {
+            r = (PySequence_SetItem(o, i, s) != -1);
+            Py_DECREF(s);
+          }
+        }
+        return r;
+      }
+    }
+
+    return vtkPythonSequenceError(o, n, m);
+  }
+
+  return true;
+}
+
 //--------------------------------------------------------------------
 // Method for setting a python array from an n-dimensional C++ array
 
@@ -985,7 +1108,6 @@ bool vtkPythonArgs::GetValue(PyObject *o, T &a) \
   return vtkPythonGetValue(o, a); \
 }
 
-VTK_PYTHON_GET_ARG(char *)
 VTK_PYTHON_GET_ARG(const char *)
 VTK_PYTHON_GET_ARG(std::string)
 VTK_PYTHON_GET_ARG(vtkUnicodeString)
@@ -1418,6 +1540,23 @@ int vtkPythonArgs::GetArgSize(int i)
   return size;
 }
 
+//--------------------------------------------------------------------
+// Checking size of string arg.
+int vtkPythonArgs::GetStringSize(int i)
+{
+  int size = 0;
+  if (this->M + i < this->N)
+  {
+    PyObject *o = PyTuple_GET_ITEM(this->Args, this->M + i);
+    size = static_cast<int>(vtkPythonGetStringSize(o));
+    if (size == 0 && PySequence_Check(o))
+    {
+      size = static_cast<int>(PySequence_Size(o));
+    }
+  }
+  return size;
+}
+
 //--------------------------------------------------------------------
 // Check if 'm' equals 'n', and report an error for arg i if not.
 bool vtkPythonArgs::CheckSizeHint(int i, Py_ssize_t m, Py_ssize_t n)
diff --git a/Wrapping/PythonCore/vtkPythonArgs.h b/Wrapping/PythonCore/vtkPythonArgs.h
index 7a9fe808df9be73866819b690bc9492ddb5a3883..c0c5c9750943ce6933bf55ef1b351f4e10771a4a 100644
--- a/Wrapping/PythonCore/vtkPythonArgs.h
+++ b/Wrapping/PythonCore/vtkPythonArgs.h
@@ -126,6 +126,14 @@ public:
    */
   bool NoArgsLeft() { return (this->I >= this->N); }
 
+  /**
+   * Get the size of an arg, if it is a string.
+   * The returned size does not include the null byte.
+   * If the arg is out of range, or is not a string,
+   * then it returns 0 but doesn't set error.
+   */
+  int GetStringSize(int i);
+
   /**
    * Get the size of an arg, if it is a sequence.
    * If no size is available, or if the arg is out of range,
@@ -303,8 +311,6 @@ public:
    */
   bool GetValue(const char *&v);
   static bool GetValue(PyObject *o, const char *&v);
-  bool GetValue(char *&v);
-  static bool GetValue(PyObject *o, char *&v);
   bool GetValue(std::string &v);
   static bool GetValue(PyObject *o, std::string &v);
   bool GetValue(vtkUnicodeString &v);
diff --git a/Wrapping/PythonCore/vtkPythonOverload.cxx b/Wrapping/PythonCore/vtkPythonOverload.cxx
index 64b1145aee10458efb1be885c773197e6ce4989a..542e09dcd31c6a1d3a57e462979c019532f74b66 100644
--- a/Wrapping/PythonCore/vtkPythonOverload.cxx
+++ b/Wrapping/PythonCore/vtkPythonOverload.cxx
@@ -464,7 +464,7 @@ int vtkPythonOverload::CheckArg(
 #endif
       }
 #endif
-      else if (!PyBytes_Check(arg))
+      else if (!PyBytes_Check(arg) && !PyByteArray_Check(arg))
       {
         penalty = VTK_PYTHON_INCOMPATIBLE;
       }
diff --git a/Wrapping/Tools/vtkWrap.c b/Wrapping/Tools/vtkWrap.c
index b4dadf4f8d6a1e708bedb6c57b2381e3beb02e49..9040935ea3d2770310bed42030e154fa640ffdde 100644
--- a/Wrapping/Tools/vtkWrap.c
+++ b/Wrapping/Tools/vtkWrap.c
@@ -1021,15 +1021,11 @@ void vtkWrap_DeclareVariable(
       fprintf(fp,"const ");
     }
   }
-  /* do the same for "const char *" with initializer */
+  /* do the same for "const char *" arguments */
   else
   {
     if ((val->Type & VTK_PARSE_CONST) != 0 &&
-        aType == VTK_PARSE_CHAR_PTR &&
-        val->Value &&
-        strcmp(val->Value, "0") != 0 &&
-        strcmp(val->Value, "nullptr") != 0 &&
-        strcmp(val->Value, "NULL") != 0)
+        aType == VTK_PARSE_CHAR_PTR)
     {
       fprintf(fp,"const ");
     }
diff --git a/Wrapping/Tools/vtkWrapPythonMethod.c b/Wrapping/Tools/vtkWrapPythonMethod.c
index 40995fd0bc9cf838becb229fb759090e00c95dcd..965175cea163e7cc2edd16a00a5dc7ad8d7d3b79 100644
--- a/Wrapping/Tools/vtkWrapPythonMethod.c
+++ b/Wrapping/Tools/vtkWrapPythonMethod.c
@@ -102,7 +102,8 @@ void vtkWrapPython_DeclareVariables(
 
     /* temps for arrays */
     if (vtkWrap_IsArray(arg) || vtkWrap_IsNArray(arg) ||
-        vtkWrap_IsPODPointer(arg))
+        vtkWrap_IsPODPointer(arg) ||
+        (vtkWrap_IsCharPointer(arg) && !vtkWrap_IsConst(arg)))
     {
       /* for non-const arrays, alloc twice as much space */
       const char *mtwo = "";
@@ -110,7 +111,24 @@ void vtkWrapPython_DeclareVariables(
       {
         mtwo = "2*";
       }
-      if (arg->CountHint || vtkWrap_IsPODPointer(arg))
+      if (vtkWrap_IsCharPointer(arg))
+      {
+        /* prepare for "char *" arg for non-const char pointer */
+        fprintf(fp,
+              "  int size%d = ap.GetStringSize(%d);\n"
+              "  vtkPythonArgs::Array<char> store%d(%ssize%d + 1);\n"
+              "  char *temp%d = store%d.Data();\n",
+              i, i,
+              i, mtwo, i,
+              i, i);
+        if (!vtkWrap_IsRef(arg))
+        {
+          fprintf(fp,
+              "  char *save%d = temp%d + size%d + 1;\n",
+              i, i, i);
+        }
+      }
+      else if (arg->CountHint || vtkWrap_IsPODPointer(arg))
       {
         /* prepare for "T *" arg, where T is a plain type */
         fprintf(fp,
@@ -306,7 +324,7 @@ void vtkWrapPython_GetSingleArgument(
             prefix, argname, i, i);
   }
   else if (vtkWrap_IsString(arg) ||
-           vtkWrap_IsCharPointer(arg))
+           (vtkWrap_IsCharPointer(arg) && vtkWrap_IsConst(arg)))
   {
     fprintf(fp, "%sGetValue(%stemp%d)",
             prefix, argname, i);
@@ -328,7 +346,8 @@ void vtkWrapPython_GetSingleArgument(
     fprintf(fp, "%sGetArray(%stemp%d, size%d)",
             prefix, argname, i, i);
   }
-  else if (vtkWrap_IsPODPointer(arg))
+  else if (vtkWrap_IsPODPointer(arg) ||
+           vtkWrap_IsCharPointer(arg))
   {
     fprintf(fp, "%sGetArray(%stemp%d, size%d)",
             prefix, argname, i, i);
@@ -751,13 +770,14 @@ void vtkWrapPython_SaveArrayArgs(FILE *fp, FunctionInfo *currentFunction)
   {
     arg = currentFunction->Parameters[i];
     n = arg->NumberOfDimensions;
-    if (n < 1 && (vtkWrap_IsArray(arg) || vtkWrap_IsPODPointer(arg)))
+    if (n < 1 && (vtkWrap_IsArray(arg) || vtkWrap_IsPODPointer(arg) ||
+                  vtkWrap_IsCharPointer(arg)))
     {
       n = 1;
     }
 
     if ((vtkWrap_IsArray(arg) || vtkWrap_IsNArray(arg) ||
-         vtkWrap_IsPODPointer(arg)) &&
+         vtkWrap_IsPODPointer(arg) || vtkWrap_IsCharPointer(arg)) &&
         (arg->Type & VTK_PARSE_CONST) == 0 &&
         !vtkWrap_IsRef(arg))
     {
@@ -1005,7 +1025,8 @@ static void vtkWrapPython_WriteBackToArgs(
   {
     arg = currentFunction->Parameters[i];
     n = arg->NumberOfDimensions;
-    if (n < 1 && (vtkWrap_IsArray(arg) || vtkWrap_IsPODPointer(arg)))
+    if (n < 1 && (vtkWrap_IsArray(arg) || vtkWrap_IsPODPointer(arg) ||
+                  (vtkWrap_IsCharPointer(arg) && !vtkWrap_IsConst(arg))))
     {
       n = 1;
     }
@@ -1044,7 +1065,7 @@ static void vtkWrapPython_WriteBackToArgs(
               "    }\n");
     }
     else if ((vtkWrap_IsArray(arg) || vtkWrap_IsNArray(arg) ||
-              vtkWrap_IsPODPointer(arg)) &&
+              vtkWrap_IsPODPointer(arg) || vtkWrap_IsCharPointer(arg)) &&
              !vtkWrap_IsConst(arg) &&
              !vtkWrap_IsSetVectorMethod(currentFunction))
     {
diff --git a/Wrapping/Tools/vtkWrapPythonMethodDef.c b/Wrapping/Tools/vtkWrapPythonMethodDef.c
index 6b9c4a156133d41301b402a694070164330ea685..a95362f216d9e2f391c95c1625e8fae38c4cfc64 100644
--- a/Wrapping/Tools/vtkWrapPythonMethodDef.c
+++ b/Wrapping/Tools/vtkWrapPythonMethodDef.c
@@ -641,7 +641,7 @@ static void vtkWrapPython_CustomMethods(
             "  vtkObjectBase *vp = ap.GetSelfPointer(self, args);\n"
             "  %s *op = static_cast<%s *>(vp);\n"
             "\n"
-            "  char *temp0s = nullptr;\n"
+            "  const char *temp0s = nullptr;\n"
             "  int temp0i = 0;\n"
             "  PyObject *temp1 = nullptr;\n"
             "  float temp2 = 0.0f;\n"
@@ -742,7 +742,7 @@ static void vtkWrapPython_CustomMethods(
       "z", "", "i", "d", "V *vtkObjectBase" };
 
     static const char *callBackTypeDecl[] = {
-      "  char *calldata = nullptr;\n",
+      "  const char *calldata = nullptr;\n",
       "",
       "  long calldata;\n",
       "  double calldata;\n",
@@ -756,7 +756,7 @@ static void vtkWrapPython_CustomMethods(
       " &&\n      ap.GetVTKObject(calldata, \"vtkObject\")" };
 
     static const char *methodCallSecondHalf[] = {
-      ", calldata",
+      ", const_cast<char *>(calldata)",
       "",
       ", &calldata",
       ", &calldata",
@@ -766,7 +766,7 @@ static void vtkWrapPython_CustomMethods(
     static const char *eventTypeString[] = { "L", "z" };
     static const char *eventTypeDecl[] = {
       "  unsigned long event;\n",
-      "  char *event = nullptr;\n" };
+      "  const char *event = nullptr;\n" };
 
     int callBackIdx, eventIdx;
 
@@ -890,7 +890,7 @@ static void vtkWrapPython_CustomMethods(
             "  vtkObjectBase *vp = ap.GetSelfPointer(self, args);\n"
             "  %s *op = static_cast<%s *>(vp);\n"
             "\n"
-            "  char *temp0;\n"
+            "  const char *temp0;\n"
             "  char tempr[256];\n"
             "  PyObject *result = nullptr;\n"
             "\n"
