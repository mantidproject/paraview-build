diff --git a/Filters/Core/vtkGridSynchronizedTemplates3D.cxx b/Filters/Core/vtkGridSynchronizedTemplates3D.cxx
index dd3b167..2ff0170 100644
--- a/Filters/Core/vtkGridSynchronizedTemplates3D.cxx
+++ b/Filters/Core/vtkGridSynchronizedTemplates3D.cxx
@@ -14,9 +14,12 @@
 =========================================================================*/
 #include "vtkSynchronizedTemplates3D.h"
 
+#include "vtkArrayDispatch.h"
+#include "vtkAssume.h"
 #include "vtkCellArray.h"
 #include "vtkCellData.h"
 #include "vtkCharArray.h"
+#include "vtkDataArrayAccessor.h"
 #include "vtkDoubleArray.h"
 #include "vtkFloatArray.h"
 #include "vtkGridSynchronizedTemplates3D.h"
@@ -26,6 +29,7 @@
 #include "vtkIntArray.h"
 #include "vtkLongArray.h"
 #include "vtkMath.h"
+#include "vtkNew.h"
 #include "vtkObjectFactory.h"
 #include "vtkPointData.h"
 #include "vtkPolyData.h"
@@ -191,100 +195,97 @@ static void vtkGridSynchronizedTemplates3DInitializeOutput(
 // Close to central differences for a grid as I could get.
 // Given a linear gradient assumption find gradient that minimizes
 // error squared for + and - (*3) neighbors).
-template <class T, class PointsType>
-void ComputeGridPointGradient(int i, int j, int k, int inExt[6],
-                              int incY, int incZ, T *sc, PointsType* pt,
-                              double g[3])
+template <class ScalarsType, class PointsType>
+void ComputeGridPointGradient(int i, int j, int k, const int inExt[6], int incY,
+                              int incZ, ScalarsType scalars, vtkIdType sc,
+                              PointsType *pt, PointsType g[3])
 {
-  double N[6][3];
-  double NtN[3][3], NtNi[3][3];
-  double *NtN2[3], *NtNi2[3];
-  double tmpDoubleArray[3];
-  int tmpIntArray[3];
-  double s[6], Nts[3], sum;
+  PointsType N[6][3];
+  typename ScalarsType::APIType s[6], Nts[3];
   int count = 0;
-  T *s2;
-  PointsType *p2;
 
-  if (i == 2 && k == 2)
-  {
-    count = 0;
-  }
+  const typename ScalarsType::APIType scValue = scalars.Get(sc, 0);
 
   // x-direction
   if (i > inExt[0])
   {
-    p2 = pt - 3;
-    s2 = sc - 1;
+    PointsType *p2 = pt - 3;
     N[count][0] = p2[0] - pt[0];
     N[count][1] = p2[1] - pt[1];
     N[count][2] = p2[2] - pt[2];
-    s[count] = static_cast<double>(*s2) - static_cast<double>(*sc);
+
+    vtkIdType s2 = sc - 1;
+    s[count] = scalars.Get(s2, 0) - scValue;
     ++count;
   }
   if (i < inExt[1])
   {
-    p2 = pt + 3;
-    s2 = sc + 1;
+    PointsType *p2 = pt + 3;
     N[count][0] = p2[0] - pt[0];
     N[count][1] = p2[1] - pt[1];
     N[count][2] = p2[2] - pt[2];
-    s[count] = static_cast<double>(*s2) - static_cast<double>(*sc);
+
+    vtkIdType s2 = sc + 1;
+    s[count] = scalars.Get(s2, 0) - scValue;
     ++count;
   }
 
   // y-direction
   if (j > inExt[2])
   {
-    p2 = pt - 3*incY;
-    s2 = sc - incY;
+    PointsType *p2 = pt - 3*incY;
     N[count][0] = p2[0] - pt[0];
     N[count][1] = p2[1] - pt[1];
     N[count][2] = p2[2] - pt[2];
-    s[count] = static_cast<double>(*s2) - static_cast<double>(*sc);
+
+    vtkIdType s2 = sc - incY;
+    s[count] = scalars.Get(s2, 0) - scValue;
+    ;
     ++count;
   }
   if (j < inExt[3])
   {
-    p2 = pt + 3*incY;
-    s2 = sc + incY;
+    PointsType* p2 = pt + 3*incY;
     N[count][0] = p2[0] - pt[0];
     N[count][1] = p2[1] - pt[1];
     N[count][2] = p2[2] - pt[2];
-    s[count] = static_cast<double>(*s2) - static_cast<double>(*sc);
+    vtkIdType s2 = sc + incY;
+    s[count] = scalars.Get(s2, 0) - scValue;
     ++count;
   }
 
   // z-direction
   if (k > inExt[4])
   {
-    p2 = pt - 3*incZ;
-    s2 = sc - incZ;
+    PointsType *p2 = pt - 3*incZ;
     N[count][0] = p2[0] - pt[0];
     N[count][1] = p2[1] - pt[1];
     N[count][2] = p2[2] - pt[2];
-    s[count] = static_cast<double>(*s2) - static_cast<double>(*sc);
+    vtkIdType s2 = sc - incZ;
+    s[count] = scalars.Get(s2, 0) - scValue;
     ++count;
   }
   if (k < inExt[5])
   {
-    p2 = pt + 3*incZ;
-    s2 = sc + incZ;
+    PointsType *p2 = pt + 3*incZ;
     N[count][0] = p2[0] - pt[0];
     N[count][1] = p2[1] - pt[1];
     N[count][2] = p2[2] - pt[2];
-    s[count] = static_cast<double>(*s2) - static_cast<double>(*sc);
+    vtkIdType s2 = sc + incZ;
+    s[count] = scalars.Get(s2, 0) - scValue;
     ++count;
   }
 
   // compute transpose(N)N.
   // since this will be a symetric matrix, we could make the
   // computation a little more efficient.
+double NtN[3][3], NtNi[3][3];
+double *NtN2[3], *NtNi2[3];
   for (i = 0; i < 3; ++i)
   {
     for (j = 0; j < 3; ++j)
     {
-      sum = 0.0;
+      PointsType sum = 0.0;
       for (k = 0; k < count; ++k)
       {
         sum += N[k][i] * N[k][j];
@@ -300,6 +301,8 @@ void ComputeGridPointGradient(int i, int j, int k, int inExt[6],
   NtNi2[0] = &(NtNi[0][0]);
   NtNi2[1] = &(NtNi[1][0]);
   NtNi2[2] = &(NtNi[2][0]);
+  double tmpDoubleArray[3];
+  int tmpIntArray[3];
   if (vtkMath::InvertMatrix(NtN2, NtNi2, 3, tmpIntArray, tmpDoubleArray) == 0)
   {
     vtkGenericWarningMacro("Cannot compute gradient of grid");
@@ -309,7 +312,7 @@ void ComputeGridPointGradient(int i, int j, int k, int inExt[6],
   // compute transpose(N)s.
   for (i = 0; i < 3; ++i)
   {
-    sum = 0.0;
+    PointsType sum = 0.0;
     for (j = 0; j < count; ++j)
     {
       sum += N[j][i] * s[j];
@@ -320,7 +323,7 @@ void ComputeGridPointGradient(int i, int j, int k, int inExt[6],
   // now compute gradient
   for (i = 0; i < 3; ++i)
   {
-    sum = 0.0;
+    PointsType sum = 0.0;
     for (j = 0; j < 3; ++j)
     {
       sum += NtNi[j][i] * Nts[j];
@@ -330,37 +333,60 @@ void ComputeGridPointGradient(int i, int j, int k, int inExt[6],
 }
 
 //----------------------------------------------------------------------------
-#define VTK_CSP3PA(i2,j2,k2,s,p, grad, norm) \
-if (NeedGradients) \
-{ \
-  if (!g0) \
-  { \
-    ComputeGridPointGradient(i, j, k, inExt, incY, incZ, s0, p0, n0); \
-    g0 = 1; \
-  } \
-  ComputeGridPointGradient(i2, j2, k2, inExt, incY, incZ, s, p, n1); \
-  for (jj=0; jj<3; jj++) \
-  { \
-    grad[jj] = n0[jj] + t * (n1[jj] - n0[jj]); \
-  } \
-  if (ComputeGradients) \
-  { \
-    newGradients->InsertNextTuple(grad); \
-  } \
-  if (ComputeNormals) \
-  { \
-    norm[0] = -grad[0];  norm[1] = -grad[1];  norm[2] = -grad[2]; \
-    vtkMath::Normalize(norm); \
-    newNormals->InsertNextTuple(norm); \
-  }   \
-} \
-if (ComputeScalars) \
-{ \
-  newScalars->InsertNextTuple(&value); \
+#define VTK_CSP3PA(i2, j2, k2, s, p)                                         \
+if (NeedGradients) {                                                         \
+  PointsType n0[3], n1[3];                                                   \
+  if (!g0) {                                                                 \
+    ComputeGridPointGradient(i, j, k, inExt, incY, incZ, scalars, s0, p0,    \
+                              n0);                                           \
+    g0 = 1;                                                                  \
+  }                                                                          \
+  ComputeGridPointGradient(i2, j2, k2, inExt, incY, incZ, scalars, s, p,     \
+                            n1);                                             \
+  PointsType grad[3];                                                        \
+  for (int jj = 0; jj < 3; jj++)                                             \
+  {                                                                          \
+    grad[jj] = n0[jj] + t * (n1[jj] - n0[jj]);                               \
+  }                                                                          \
+  if (ComputeGradients)                                                      \
+  {                                                                          \
+    newGradients->InsertNextTuple(grad);                                     \
+  }                                                                          \
+  if (ComputeNormals)                                                        \
+  {                                                                          \
+    PointsType norm[3] = {-grad[0], -grad[1] - grad[2]};                     \
+    vtkMath::Normalize(norm);                                                \
+    newNormals->InsertNextTuple(norm);                                       \
+  }                                                                          \
+}                                                                            \
+if (ComputeScalars)                                                          \
+{                                                                            \
+  newScalars->InsertNextTuple(&value);                                       \
 }
 
 namespace
 {
+
+const int *GetTablePtr(bool v0, int *isect1Ptr, int *isect2Ptr,
+                       int yisectstep)
+{
+  int idx = (v0 ? 4096 : 0);
+  idx = idx + (*(isect1Ptr - yisectstep) > -1 ? 2048 : 0);
+  idx = idx + (*(isect1Ptr - yisectstep + 1) > -1 ? 1024 : 0);
+  idx = idx + (*(isect1Ptr - yisectstep + 2) > -1 ? 512 : 0);
+  idx = idx + (*(isect1Ptr - yisectstep + 4) > -1 ? 256 : 0);
+  idx = idx + (*(isect1Ptr - yisectstep + 5) > -1 ? 128 : 0);
+  idx = idx + (*(isect1Ptr) > -1 ? 64 : 0);
+  idx = idx + (*(isect1Ptr + 2) > -1 ? 32 : 0);
+  idx = idx + (*(isect1Ptr + 5) > -1 ? 16 : 0);
+  idx = idx + (*(isect2Ptr - yisectstep) > -1 ? 8 : 0);
+  idx = idx + (*(isect2Ptr - yisectstep + 1) > -1 ? 4 : 0);
+  idx = idx + (*(isect2Ptr - yisectstep + 4) > -1 ? 2 : 0);
+  idx = idx + (*(isect2Ptr) > -1 ? 1 : 0);
+  return VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_2 +
+         VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_1[idx];
+}
+
 class CellVisibility
 {
 public:
@@ -393,7 +419,7 @@ public:
       case POINTS:
         return this->InputStructuredGrid->IsCellVisible(id) ? true : false;
       default:
-        return 1;
+        return true;
     }
   }
 private:
@@ -407,446 +433,429 @@ private:
 
 //----------------------------------------------------------------------------
 // Contouring filter specialized for structured grids
-template <class T, class PointsType>
-void ContourGrid(vtkGridSynchronizedTemplates3D *self,
-                 int *exExt, T *scalars,
-                 vtkStructuredGrid *input, vtkPolyData *output, PointsType*, vtkDataArray *inScalars, bool outputTriangles)
+struct ContourGridWorker
 {
-  int *inExt = input->GetExtent();
-  int xdim = exExt[1] - exExt[0] + 1;
-  int ydim = exExt[3] - exExt[2] + 1;
-  double n0[3], n1[3];  // used in gradient macro
-  double *values = self->GetValues();
-  int numContours = self->GetNumberOfContours();
-  PointsType *inPtPtrX, *inPtPtrY, *inPtPtrZ;
-  PointsType *p0, *p1, *p2, *p3;
-  T *inPtrX, *inPtrY, *inPtrZ;
-  T *s0, *s1, *s2, *s3;
-  int XMin, XMax, YMin, YMax, ZMin, ZMax;
-  int incY, incZ;
-  PointsType* points =
-    static_cast<PointsType*>(input->GetPoints()->GetData()->GetVoidPointer(0));
-  double t;
-  int *isect1Ptr, *isect2Ptr;
-  vtkIdType ptIds[3];
-  int *tablePtr;
-  int v0, v1, v2, v3;
-  int idx, vidx;
-  double value;
-  int i, j, k;
-  int zstep, yisectstep;
-  int offsets[12];
-  int ComputeNormals = self->GetComputeNormals();
-  int ComputeGradients = self->GetComputeGradients();
-  int ComputeScalars = self->GetComputeScalars();
-  int NeedGradients = ComputeGradients || ComputeNormals;
-  int jj, g0;
-  // We need to know the edgePointId's for interpolating attributes.
-  vtkIdType edgePtId, inCellId, outCellId;
-  vtkPointData *inPD = input->GetPointData();
-  vtkCellData *inCD = input->GetCellData();
-  CellVisibility isCellVisible(input);
-  vtkPointData *outPD = output->GetPointData();
-  vtkCellData *outCD = output->GetCellData();
-  // Temporary point data.
-  double x[3];
-  double grad[3];
-  double norm[3];
-  // Used to be passed in as parameteters.
-  vtkCellArray *newPolys;
-  vtkPoints *newPts;
-  vtkFloatArray *newScalars = NULL;
-  vtkFloatArray *newNormals = NULL;
-  vtkFloatArray *newGradients = NULL;
-  vtkPolygonBuilder polyBuilder;
-  vtkSmartPointer<vtkIdListCollection> polys =
-    vtkSmartPointer<vtkIdListCollection>::New();
-
-  if (ComputeScalars)
-  {
-    newScalars = vtkFloatArray::New();
-  }
-  if (ComputeNormals)
+  vtkGridSynchronizedTemplates3D *self;
+  int *exExt;
+  vtkStructuredGrid *input;
+  vtkPolyData *output;
+  bool outputTriangles;
+  ContourGridWorker(vtkGridSynchronizedTemplates3D *iself, int *iexExt,
+                    vtkStructuredGrid *iinput, vtkPolyData *ioutput,
+                    bool ioutputTriangles)
+      : self(iself), exExt(iexExt), input(iinput), output(ioutput),
+        outputTriangles(ioutputTriangles){};
+  template <class ScalarsArray, class PointsArray>
+  void operator()(ScalarsArray *scalarsarray, PointsArray *pointsarray)
   {
-    newNormals = vtkFloatArray::New();
-  }
-  if (ComputeGradients)
-  {
-    newGradients = vtkFloatArray::New();
-  }
-  vtkGridSynchronizedTemplates3DInitializeOutput(
-              exExt, self->GetOutputPointsPrecision(), input, output,
-              newScalars, newNormals, newGradients, inScalars);
-  newPts = output->GetPoints();
-  newPolys = output->GetPolys();
-
-  // this is an exploded execute extent.
-  XMin = exExt[0];
-  XMax = exExt[1];
-  YMin = exExt[2];
-  YMax = exExt[3];
-  ZMin = exExt[4];
-  ZMax = exExt[5];
-  // to skip over an x row of the input.
-  incY = inExt[1]-inExt[0]+1;
-  // to skip over an xy slice of the input.
-  incZ = (inExt[3]-inExt[2]+1)*incY;
-
-  // Kens increments, probably to do with edge array
-  zstep = xdim*ydim;
-  yisectstep = xdim*3;
-  // compute offsets probably how to get to the edges in the edge array.
-  offsets[0] = -xdim*3;
-  offsets[1] = -xdim*3 + 1;
-  offsets[2] = -xdim*3 + 2;
-  offsets[3] = -xdim*3 + 4;
-  offsets[4] = -xdim*3 + 5;
-  offsets[5] = 0;
-  offsets[6] = 2;
-  offsets[7] = 5;
-  offsets[8] = (zstep - xdim)*3;
-  offsets[9] = (zstep - xdim)*3 + 1;
-  offsets[10] = (zstep - xdim)*3 + 4;
-  offsets[11] = zstep*3;
-
-  // allocate storage array
-  int *isect1 = new int [xdim*ydim*3*2];
-  // set impossible edges to -1
-  for (i = 0; i < ydim; i++)
-  {
-    isect1[(i+1)*xdim*3-3] = -1;
-    isect1[(i+1)*xdim*3*2-3] = -1;
-  }
-  for (i = 0; i < xdim; i++)
-  {
-    isect1[((ydim-1)*xdim + i)*3 + 1] = -1;
-    isect1[((ydim-1)*xdim + i)*3*2 + 1] = -1;
-  }
-
+    VTK_ASSUME(scalarsarray->GetNumberOfComponents() == 1);
+    VTK_ASSUME(pointsarray->GetNumberOfComponents() == 3);
+    typedef typename vtkDataArrayAccessor<PointsArray>::APIType PointsType;
+    typedef typename vtkDataArrayAccessor<ScalarsArray>::APIType ScalarsType;
+    PointsType *points = pointsarray->GetPointer(0);
+    vtkDataArrayAccessor<ScalarsArray> scalars(scalarsarray);
+
+    const int *const inExt = input->GetExtent();
+    const int xdim = exExt[1] - exExt[0] + 1;
+    const int ydim = exExt[3] - exExt[2] + 1;
+    const bool ComputeNormals = self->GetComputeNormals();
+    const bool ComputeGradients = self->GetComputeGradients();
+    const bool ComputeScalars = self->GetComputeScalars();
+    const bool NeedGradients = ComputeGradients | ComputeNormals;
+    const double *const values = self->GetValues();
+    const int numContours = self->GetNumberOfContours();
+    const vtkSmartPointer<vtkIdListCollection> polys =
+        vtkSmartPointer<vtkIdListCollection>::New();
+    vtkPointData *inPD = input->GetPointData();
+    vtkCellData *inCD = input->GetCellData();
+    CellVisibility isCellVisible(input);
+    vtkPointData *outPD = output->GetPointData();
+    vtkCellData *outCD = output->GetCellData();
+
+    // Used to be passed in as parameteters.
+    vtkPolygonBuilder polyBuilder;
+
+    vtkFloatArray *newScalars = NULL;
+    if (ComputeScalars)
+    {
+      newScalars = vtkFloatArray::New();
+    }
 
-  //fprintf(stderr, "%d: -------- Extent %d, %d, %d, %d, %d, %d\n", threadId,
-  //      exExt[0], exExt[1], exExt[2], exExt[3], exExt[4], exExt[5]);
+    vtkFloatArray *newNormals = NULL;
+    if (ComputeNormals)
+    {
+      newNormals = vtkFloatArray::New();
+    }
 
-  // for each contour
-  for (vidx = 0; vidx < numContours; vidx++)
-  {
-    value = values[vidx];
-    //  skip any slices which are overlap for computing gradients.
-    inPtPtrZ = points + 3*((ZMin - inExt[4]) * incZ +
-                           (YMin - inExt[2]) * incY +
-                           (XMin - inExt[0]));
-    inPtrZ = scalars + ((ZMin - inExt[4]) * incZ +
-                        (YMin - inExt[2]) * incY +
-                        (XMin - inExt[0]));
-    s2 = inPtrZ;
-
-    //==================================================================
-    for (k = ZMin; k <= ZMax; k++)
+    vtkFloatArray *newGradients = NULL;
+    if (ComputeGradients)
     {
-      // swap the buffers
-      if (k%2)
-      {
-        offsets[8] = (zstep - xdim)*3;
-        offsets[9] = (zstep - xdim)*3 + 1;
-        offsets[10] = (zstep - xdim)*3 + 4;
-        offsets[11] = zstep*3;
-        isect1Ptr = isect1;
-        isect2Ptr = isect1 + xdim*ydim*3;
-      }
-      else
+      newGradients = vtkFloatArray::New();
+    }
+    vtkGridSynchronizedTemplates3DInitializeOutput(
+        exExt, self->GetOutputPointsPrecision(), input, output, newScalars,
+        newNormals, newGradients, scalarsarray);
+    vtkPoints *newPts = output->GetPoints();
+    vtkCellArray *newPolys = output->GetPolys();
+
+    // this is an exploded execute extent.
+    const int XMin = exExt[0];
+    const int XMax = exExt[1];
+    const int YMin = exExt[2];
+    const int YMax = exExt[3];
+    const int ZMin = exExt[4];
+    const int ZMax = exExt[5];
+    // to skip over an x row of the input.
+    const int incY = inExt[1] - inExt[0] + 1;
+    // to skip over an xy slice of the input.
+    const int incZ = (inExt[3] - inExt[2] + 1) * incY;
+
+    // Kens increments, probably to do with edge array
+    const int zstep = xdim * ydim;
+    const int yisectstep = xdim * 3;
+
+    int offsets[12];
+    // compute offsets probably how to get to the edges in the edge array.
+    offsets[0] = -xdim * 3;
+    offsets[1] = -xdim * 3 + 1;
+    offsets[2] = -xdim * 3 + 2;
+    offsets[3] = -xdim * 3 + 4;
+    offsets[4] = -xdim * 3 + 5;
+    offsets[5] = 0;
+    offsets[6] = 2;
+    offsets[7] = 5;
+    offsets[8] = (zstep - xdim) * 3;
+    offsets[9] = (zstep - xdim) * 3 + 1;
+    offsets[10] = (zstep - xdim) * 3 + 4;
+    offsets[11] = zstep * 3;
+
+    // allocate storage array
+    vtkNew<vtkIntArray> temp;
+    temp->SetNumberOfComponents(3);
+    temp->SetNumberOfTuples(xdim * ydim * 2);
+    int *isect1 = temp->GetPointer(0);
+    // set impossible edges to -1
+    for (int i = 0; i < ydim; i++)
+    {
+      isect1[(i + 1) * xdim * 3 - 3] = -1;
+      isect1[(i + 1) * xdim * 3 * 2 - 3] = -1;
+    }
+    for (int i = 0; i < xdim; i++)
+    {
+      isect1[((ydim - 1) * xdim + i) * 3 + 1] = -1;
+      isect1[((ydim - 1) * xdim + i) * 3 * 2 + 1] = -1;
+    }
+    // for each contour
+    for (int vidx = 0; vidx < numContours; vidx++)
+    {
+      const ScalarsType value = values[vidx];
+      //  skip any slices which are overlap for computing gradients.
+      PointsType *inPtPtrZ =
+          points +
+          3 * ((ZMin - inExt[4]) * incZ + (YMin - inExt[2]) * incY +
+                (XMin - inExt[0]));
+      vtkIdType inIdxZ = ((ZMin - inExt[4]) * incZ +
+                          (YMin - inExt[2]) * incY + (XMin - inExt[0]));
+
+      //==================================================================
+      for (int k = ZMin; k <= ZMax; k++)
       {
-        offsets[8] = (-zstep - xdim)*3;
-        offsets[9] = (-zstep - xdim)*3 + 1;
-        offsets[10] = (-zstep - xdim)*3 + 4;
-        offsets[11] = -zstep*3;
-        isect1Ptr = isect1 + xdim*ydim*3;
-        isect2Ptr = isect1;
-      }
+        int *isect1Ptr, *isect2Ptr;
+        // swap the buffers
+        if (k % 2)
+        {
+          offsets[8] = (zstep - xdim) * 3;
+          offsets[9] = (zstep - xdim) * 3 + 1;
+          offsets[10] = (zstep - xdim) * 3 + 4;
+          offsets[11] = zstep * 3;
+          isect1Ptr = isect1;
+          isect2Ptr = isect1 + xdim * ydim * 3;
+        }
+        else
+        {
+          offsets[8] = (-zstep - xdim) * 3;
+          offsets[9] = (-zstep - xdim) * 3 + 1;
+          offsets[10] = (-zstep - xdim) * 3 + 4;
+          offsets[11] = -zstep * 3;
+          isect1Ptr = isect1 + xdim * ydim * 3;
+          isect2Ptr = isect1;
+        }
 
-      inPtPtrY = inPtPtrZ;
-      inPtrY = inPtrZ;
-      for (j = YMin; j <= YMax; j++)
-      {
-        // Should not impact performance here/
-        edgePtId = (j-inExt[2])*incY + (k-inExt[4])*incZ;
-        // Increments are different for cells.
-        // Since the cells are not contoured until the second row of templates,
-        // subtract 1 from i,j,and k.  Note: first cube is formed when i=0, j=1, and k=1.
-        inCellId = (XMin-inExt[0]) + (inExt[1]-inExt[0])*( (j-inExt[2]-1) + (k-inExt[4]-1)*(inExt[3]-inExt[2]) );
-
-        p1 = inPtPtrY;
-        s1 = inPtrY;
-        v1 = (*s1 < value ? 0 : 1);
-        inPtPtrX = inPtPtrY;
-        inPtrX = inPtrY;
-        // inCellId is ised to keep track of ids for copying cell attributes.
-        for (i = XMin; i <= XMax; i++, inCellId++)
+        PointsType *inPtPtrY = inPtPtrZ;
+        vtkIdType inIdxY = inIdxZ;
+        for (int j = YMin; j <= YMax; j++)
         {
-          p0 = p1;
-          s0 = s1;
-          v0 = v1;
-          // this flag keeps up from computing gradient for grid point 0 twice.
-          g0 = 0;
-          *isect2Ptr = -1;
-          *(isect2Ptr + 1) = -1;
-          *(isect2Ptr + 2) = -1;
-          if (i < XMax)
+          // Should not impact performance here/
+          vtkIdType edgePtId = (j - inExt[2]) * incY + (k - inExt[4]) * incZ;
+          // Increments are different for cells.
+          // Since the cells are not contoured until the second row of
+          // templates,
+          // subtract 1 from i,j,and k.  Note: first cube is formed when i=0,
+          // j=1, and k=1.
+          vtkIdType inCellId = (XMin - inExt[0]) +
+                (inExt[1] - inExt[0]) * ((j - inExt[2] - 1) +
+                (k - inExt[4] - 1) * (inExt[3] - inExt[2]));
+
+          PointsType *p1 = inPtPtrY;
+          vtkIdType s1 = inIdxY;
+          ScalarsType s1Value = scalars.Get(s1, 0);
+          bool v1 = !(s1Value < value);
+          PointsType *inPtPtrX = inPtPtrY;
+          vtkIdType inIdxX = inIdxY;
+          // inCellId is used to keep track of ids for copying cell
+          // attributes.
+          for (int i = XMin; i <= XMax; i++, inCellId++)
           {
-            p1 = (inPtPtrX + 3);
-            s1 = (inPtrX + 1);
-            v1 = (*s1 < value ? 0 : 1);
-            if (v0 ^ v1)
+            PointsType *p0 = p1;
+            vtkIdType s0 = s1;
+            ScalarsType s0Value = scalars.Get(s0, 0);
+            bool v0 = v1;
+            // this flag keeps up from computing gradient for grid point 0
+            // twice.
+            int g0 = 0;
+            *isect2Ptr = -1;
+            *(isect2Ptr + 1) = -1;
+            *(isect2Ptr + 2) = -1;
+            if (i < XMax)
             {
-              // watch for degenerate points
-              if (*s0 == value)
+              p1 = (inPtPtrX + 3);
+              s1 = (inIdxX + 1);
+              ScalarsType s1Value = scalars.Get(s1, 0);
+              v1 = !(s1Value < value);
+              if (v0 != v1)
               {
-                if (i > XMin && *(isect2Ptr-3) > -1)
-                {
-                  *isect2Ptr = *(isect2Ptr-3);
-                }
-                else if (j > XMin && *(isect2Ptr - yisectstep + 1) > -1)
+                // watch for degenerate points
+                if (s0Value == value)
                 {
-                  *isect2Ptr = *(isect2Ptr - yisectstep + 1);
-                }
-                else if (k > ZMin && *(isect1Ptr+2) > -1)
-                {
-                  *isect2Ptr = *(isect1Ptr+2);
+                  if (i > XMin && *(isect2Ptr - 3) > -1)
+                  {
+                    *isect2Ptr = *(isect2Ptr - 3);
+                  }
+                  else if (j > XMin && *(isect2Ptr - yisectstep + 1) > -1)
+                  {
+                    *isect2Ptr = *(isect2Ptr - yisectstep + 1);
+                  }
+                  else if (k > ZMin && *(isect1Ptr + 2) > -1)
+                  {
+                    *isect2Ptr = *(isect1Ptr + 2);
+                  }
                 }
-              }
-              else if (*s1 == value)
-              {
-                if (j > YMin && *(isect2Ptr - yisectstep +4) > -1)
+                else if (s1Value == value)
                 {
-                  *isect2Ptr = *(isect2Ptr - yisectstep + 4);
+                  if (j > YMin && *(isect2Ptr - yisectstep + 4) > -1)
+                  {
+                    *isect2Ptr = *(isect2Ptr - yisectstep + 4);
+                  }
+                  else if (k > ZMin && i<XMax &&*(isect1Ptr + 5)> - 1)
+                  {
+                    *isect2Ptr = *(isect1Ptr + 5);
+                  }
                 }
-                else if (k > ZMin && i < XMax && *(isect1Ptr + 5) > -1)
+                // if the edge has not been set yet then it is a new point
+                if (*isect2Ptr == -1)
                 {
-                  *isect2Ptr = *(isect1Ptr + 5);
+                  ScalarsType t = (value - s0Value) / (s1Value - s0Value);
+                  PointsType x[3];
+                  x[0] = p0[0] + t * (p1[0] - p0[0]);
+                  x[1] = p0[1] + t * (p1[1] - p0[1]);
+                  x[2] = p0[2] + t * (p1[2] - p0[2]);
+                  *isect2Ptr = newPts->InsertNextPoint(x);
+                  VTK_CSP3PA(i + 1, j, k, s1, p1);
+                  outPD->InterpolateEdge(inPD, *isect2Ptr, edgePtId,
+                                          edgePtId + 1, t);
                 }
               }
-              // if the edge has not been set yet then it is a new point
-              if (*isect2Ptr == -1)
-              {
-                t = (value - static_cast<double>(*s0)) / (static_cast<double>(*s1) - static_cast<double>(*s0));
-                x[0] = p0[0] + t*(p1[0] - p0[0]);
-                x[1] = p0[1] + t*(p1[1] - p0[1]);
-                x[2] = p0[2] + t*(p1[2] - p0[2]);
-                *isect2Ptr = newPts->InsertNextPoint(x);
-                VTK_CSP3PA(i+1,j,k,s1,p1,grad,norm);
-                outPD->InterpolateEdge(inPD, *isect2Ptr, edgePtId, edgePtId+1, t);
-              }
             }
-          }
-          if (j < YMax)
-          {
-            p2 = (inPtPtrX + incY*3);
-            s2 = (inPtrX + incY);
-            v2 = (*s2 < value ? 0 : 1);
-            if (v0 ^ v2)
+            if (j < YMax)
             {
-              // watch for degen points
-              if (*s0 == value)
+              PointsType *p2 = (inPtPtrX + incY * 3);
+              vtkIdType s2 = (inIdxX + incY);
+              ScalarsType s2Value = scalars.Get(s2, 0);
+              bool v2 = !(s2Value < value);
+              if (v0 != v2)
               {
-                if (*isect2Ptr > -1)
-                {
-                  *(isect2Ptr + 1) = *isect2Ptr;
-                }
-                else if (i > XMin && *(isect2Ptr-3) > -1)
+                // watch for degen points
+                if (s0Value == value)
                 {
-                  *(isect2Ptr + 1) = *(isect2Ptr-3);
+                  if (*isect2Ptr > -1)
+                  {
+                    *(isect2Ptr + 1) = *isect2Ptr;
+                  }
+                  else if (i > XMin && *(isect2Ptr - 3) > -1)
+                  {
+                    *(isect2Ptr + 1) = *(isect2Ptr - 3);
+                  }
+                  else if (j > YMin && *(isect2Ptr - yisectstep + 1) > -1)
+                  {
+                    *(isect2Ptr + 1) = *(isect2Ptr - yisectstep + 1);
+                  }
+                  else if (k > ZMin && *(isect1Ptr + 2) > -1)
+                  {
+                    *(isect2Ptr + 1) = *(isect1Ptr + 2);
+                  }
                 }
-                else if (j > YMin && *(isect2Ptr - yisectstep + 1) > -1)
+                else if (s2Value == value && k > ZMin &&
+                            *(isect1Ptr + yisectstep + 2) > -1)
                 {
-                  *(isect2Ptr + 1) = *(isect2Ptr - yisectstep + 1);
+                  *(isect2Ptr + 1) = *(isect1Ptr + yisectstep + 2);
                 }
-                else if (k > ZMin && *(isect1Ptr+2) > -1)
+                // if the edge has not been set yet then it is a new point
+                if (*(isect2Ptr + 1) == -1)
                 {
-                  *(isect2Ptr + 1) = *(isect1Ptr+2);
+                  ScalarsType t = (value - s0Value) / (s2Value - s0Value);
+                  PointsType x[3];
+                  x[0] = p0[0] + t * (p2[0] - p0[0]);
+                  x[1] = p0[1] + t * (p2[1] - p0[1]);
+                  x[2] = p0[2] + t * (p2[2] - p0[2]);
+                  *(isect2Ptr + 1) = newPts->InsertNextPoint(x);
+                  VTK_CSP3PA(i, j + 1, k, s2, p2);
+                  outPD->InterpolateEdge(inPD, *(isect2Ptr + 1), edgePtId,
+                                          edgePtId + incY, t);
                 }
               }
-              else if (*s2 == value && k > ZMin && *(isect1Ptr + yisectstep + 2) > -1)
-              {
-                *(isect2Ptr+1) = *(isect1Ptr + yisectstep + 2);
-              }
-              // if the edge has not been set yet then it is a new point
-              if (*(isect2Ptr + 1) == -1)
-              {
-                t = (value - static_cast<double>(*s0)) / (static_cast<double>(*s2) - static_cast<double>(*s0));
-                x[0] = p0[0] + t*(p2[0] - p0[0]);
-                x[1] = p0[1] + t*(p2[1] - p0[1]);
-                x[2] = p0[2] + t*(p2[2] - p0[2]);
-                *(isect2Ptr + 1) = newPts->InsertNextPoint(x);
-                VTK_CSP3PA(i,j+1,k,s2,p2,grad,norm);
-                outPD->InterpolateEdge(inPD, *(isect2Ptr+1), edgePtId,
-                                       edgePtId+incY, t);
-              }
             }
-          }
-          if (k < ZMax)
-          {
-            p3 = (inPtPtrX + incZ*3);
-            s3 = (inPtrX + incZ);
-            v3 = (*s3 < value ? 0 : 1);
-            if (v0 ^ v3)
+            if (k < ZMax)
             {
-              // watch for degen points
-              if (*s0 == value)
+              PointsType *p3 = (inPtPtrX + incZ * 3);
+              vtkIdType s3 = inIdxX + incZ;
+              ScalarsType s3Value = scalars.Get(s3, 0);
+              bool v3 = !(s3Value < value);
+              if (v0 != v3)
               {
-                if (*isect2Ptr > -1)
-                {
-                  *(isect2Ptr + 2) = *isect2Ptr;
-                }
-                else if (*(isect2Ptr+1) > -1)
+                // watch for degen points
+                if (s0Value == value)
                 {
-                  *(isect2Ptr + 2) = *(isect2Ptr+1);
-                }
-                else if (i > XMin && *(isect2Ptr-3) > -1)
-                {
-                  *(isect2Ptr + 2) = *(isect2Ptr-3);
-                }
-                else if (j > YMin && *(isect2Ptr - yisectstep + 1) > -1)
-                {
-                  *(isect2Ptr + 2) = *(isect2Ptr - yisectstep + 1);
+                  if (*isect2Ptr > -1)
+                  {
+                    *(isect2Ptr + 2) = *isect2Ptr;
+                  }
+                  else if (*(isect2Ptr + 1) > -1)
+                  {
+                    *(isect2Ptr + 2) = *(isect2Ptr + 1);
+                  }
+                  else if (i > XMin && *(isect2Ptr - 3) > -1)
+                  {
+                    *(isect2Ptr + 2) = *(isect2Ptr - 3);
+                  }
+                  else if (j > YMin && *(isect2Ptr - yisectstep + 1) > -1)
+                  {
+                    *(isect2Ptr + 2) = *(isect2Ptr - yisectstep + 1);
+                  }
+                  else if (k > ZMin && *(isect1Ptr + 2) > -1)
+                  {
+                    *(isect2Ptr + 2) = *(isect1Ptr + 2);
+                  }
                 }
-                else if (k > ZMin && *(isect1Ptr+2) > -1)
+                if (*(isect2Ptr + 2) == -1)
                 {
-                  *(isect2Ptr + 2) = *(isect1Ptr+2);
+                  ScalarsType t = (value - s0Value) / (s3Value - s0Value);
+                  PointsType x[3];
+                  x[0] = p0[0] + t * (p3[0] - p0[0]);
+                  x[1] = p0[1] + t * (p3[1] - p0[1]);
+                  x[2] = p0[2] + t * (p3[2] - p0[2]);
+                  *(isect2Ptr + 2) = newPts->InsertNextPoint(x);
+                  VTK_CSP3PA(i, j, k + 1, s3, p3);
+                  outPD->InterpolateEdge(inPD, *(isect2Ptr + 2), edgePtId,
+                                          edgePtId + incZ, t);
                 }
               }
-              if (*(isect2Ptr + 2) == -1)
-              {
-                t = (value - static_cast<double>(*s0)) / (static_cast<double>(*s3) - static_cast<double>(*s0));
-                x[0] = p0[0] + t*(p3[0] - p0[0]);
-                x[1] = p0[1] + t*(p3[1] - p0[1]);
-                x[2] = p0[2] + t*(p3[2] - p0[2]);
-                *(isect2Ptr + 2) = newPts->InsertNextPoint(x);
-                VTK_CSP3PA(i,j,k+1,s3,p3,grad,norm);
-                outPD->InterpolateEdge(inPD, *(isect2Ptr+2),
-                                       edgePtId, edgePtId+incZ, t);
-              }
             }
-          }
 
-          // To keep track of ids for interpolating attributes.
-          ++edgePtId;
+            // To keep track of ids for interpolating attributes.
+            ++edgePtId;
 
-          // now add any polys that need to be added
-          // basically look at the isect values,
-          // form an index and lookup the polys
-          if (j > YMin && i < XMax && k > ZMin)
-          {
-            idx = (v0 ? 4096 : 0);
-            idx = idx + (*(isect1Ptr - yisectstep) > -1 ? 2048 : 0);
-            idx = idx + (*(isect1Ptr -yisectstep +1) > -1 ? 1024 : 0);
-            idx = idx + (*(isect1Ptr -yisectstep +2) > -1 ? 512 : 0);
-            idx = idx + (*(isect1Ptr -yisectstep +4) > -1 ? 256 : 0);
-            idx = idx + (*(isect1Ptr -yisectstep +5) > -1 ? 128 : 0);
-            idx = idx + (*(isect1Ptr) > -1 ? 64 : 0);
-            idx = idx + (*(isect1Ptr + 2) > -1 ? 32 : 0);
-            idx = idx + (*(isect1Ptr + 5) > -1 ? 16 : 0);
-            idx = idx + (*(isect2Ptr -yisectstep) > -1 ? 8 : 0);
-            idx = idx + (*(isect2Ptr -yisectstep +1) > -1 ? 4 : 0);
-            idx = idx + (*(isect2Ptr -yisectstep +4) > -1 ? 2 : 0);
-            idx = idx + (*(isect2Ptr) > -1 ? 1 : 0);
-
-            tablePtr = VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_2
-              + VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_1[idx];
-            // to protect data against multiple threads
-            if (isCellVisible(inCellId))
+            // now add any polys that need to be added
+            // basically look at the isect values,
+            // form an index and lookup the polys
+            if (j > YMin && i < XMax && k > ZMin)
             {
-              if (!outputTriangles)
-              {
-                polyBuilder.Reset();
-              }
-              while (*tablePtr != -1)
+              // to protect data against multiple threads
+              if (isCellVisible(inCellId))
               {
-                ptIds[0] = *(isect1Ptr + offsets[*tablePtr]);
-                tablePtr++;
-                ptIds[1] = *(isect1Ptr + offsets[*tablePtr]);
-                tablePtr++;
-                ptIds[2] = *(isect1Ptr + offsets[*tablePtr]);
-                tablePtr++;
-                if (ptIds[0] != ptIds[1] &&
-                    ptIds[0] != ptIds[2] &&
-                    ptIds[1] != ptIds[2])
+                if (!outputTriangles)
                 {
-                  if(outputTriangles)
-                  {
-                    outCellId = newPolys->InsertNextCell(3,ptIds);
-                    outCD->CopyData(inCD, inCellId, outCellId);
-                  }
-                  else
+                  polyBuilder.Reset();
+                }
+                const int *tablePtr =
+                    GetTablePtr(v0, isect1Ptr, isect2Ptr, yisectstep);
+                while (*tablePtr != -1)
+                {
+                  vtkIdType ptIds[3];
+                  ptIds[0] = *(isect1Ptr + offsets[*tablePtr]);
+                  tablePtr++;
+                  ptIds[1] = *(isect1Ptr + offsets[*tablePtr]);
+                  tablePtr++;
+                  ptIds[2] = *(isect1Ptr + offsets[*tablePtr]);
+                  tablePtr++;
+                  if (ptIds[0] != ptIds[1] && ptIds[0] != ptIds[2] &&
+                      ptIds[1] != ptIds[2])
                   {
-                    polyBuilder.InsertTriangle(ptIds);
+                    if (outputTriangles)
+                    {
+                      vtkIdType outCellId =
+                          newPolys->InsertNextCell(3, ptIds);
+                      outCD->CopyData(inCD, inCellId, outCellId);
+                    }
+                    else
+                    {
+                      polyBuilder.InsertTriangle(ptIds);
+                    }
                   }
                 }
-              }
-              if(!outputTriangles)
-              {
-                polyBuilder.GetPolygons(polys);
-                int nPolys = polys->GetNumberOfItems();
-                for (int polyId = 0; polyId < nPolys; ++polyId)
+                if (!outputTriangles)
                 {
-                  vtkIdList* poly = polys->GetItem(polyId);
-                  if(poly->GetNumberOfIds()!=0)
+                  polyBuilder.GetPolygons(polys);
+                  int nPolys = polys->GetNumberOfItems();
+                  for (int polyId = 0; polyId < nPolys; ++polyId)
                   {
-                    outCellId = newPolys->InsertNextCell(poly);
-                    outCD->CopyData(inCD, inCellId, outCellId);
+                    vtkIdList *poly = polys->GetItem(polyId);
+                    if (poly->GetNumberOfIds() != 0)
+                    {
+                      vtkIdType outCellId = newPolys->InsertNextCell(poly);
+                      outCD->CopyData(inCD, inCellId, outCellId);
+                    }
+                    poly->Delete();
                   }
-                  poly->Delete();
+                  polys->RemoveAllItems();
                 }
-                polys->RemoveAllItems();
               }
             }
+            inPtPtrX += 3;
+            ++inIdxX;
+            isect2Ptr += 3;
+            isect1Ptr += 3;
           }
-          inPtPtrX += 3;
-          ++inPtrX;
-          isect2Ptr += 3;
-          isect1Ptr += 3;
+          inPtPtrY += 3 * incY;
+          inIdxY += incY;
         }
-        inPtPtrY += 3*incY;
-        inPtrY += incY;
+        inPtPtrZ += 3 * incZ;
+        inIdxZ += incZ;
       }
-      inPtPtrZ += 3*incZ;
-      inPtrZ += incZ;
     }
-  }
-
-  if (newScalars)
-  {
-    newScalars->SetName(inScalars->GetName());
-    idx = output->GetPointData()->AddArray(newScalars);
-    output->GetPointData()->SetActiveAttribute(idx, vtkDataSetAttributes::SCALARS);
-    newScalars->Delete();
-    newScalars = NULL;
-  }
-  if (newGradients)
-  {
-    output->GetPointData()->SetVectors(newGradients);
-    newGradients->Delete();
-    newGradients = NULL;
-  }
-  if (newNormals)
-  {
-    output->GetPointData()->SetNormals(newNormals);
-    newNormals->Delete();
-    newNormals = NULL;
-  }
-
-  delete [] isect1;
-}
 
-template <class T>
-void ContourGrid(vtkGridSynchronizedTemplates3D *self,
-                 int *exExt, T *scalars, vtkStructuredGrid *input,
-                 vtkPolyData *output, vtkDataArray *inScalars, bool outputTriangles)
-{
-  switch(input->GetPoints()->GetData()->GetDataType())
-  {
-    vtkTemplateMacro(
-      ContourGrid(self, exExt, scalars, input, output,static_cast<VTK_TT *>(0), inScalars, outputTriangles));
+    if (newScalars)
+    {
+      newScalars->SetName(scalarsarray->GetName());
+      int idx = output->GetPointData()->AddArray(newScalars);
+      output->GetPointData()->SetActiveAttribute(
+          idx, vtkDataSetAttributes::SCALARS);
+      newScalars->Delete();
+      newScalars = NULL;
+    }
+    if (newGradients)
+    {
+      output->GetPointData()->SetVectors(newGradients);
+      newGradients->Delete();
+      newGradients = NULL;
+    }
+    if (newNormals)
+    {
+      output->GetPointData()->SetNormals(newNormals);
+      newNormals->Delete();
+      newNormals = NULL;
+    }
   }
-}
+};
 
 //----------------------------------------------------------------------------
 // Contouring filter specialized for images (or slices from images)
@@ -901,12 +910,16 @@ void vtkGridSynchronizedTemplates3D::ThreadedExecute(vtkStructuredGrid *input,
   //
   if (inScalars->GetNumberOfComponents() == 1 )
   {
-    void *scalars = inScalars->GetVoidPointer(0);
-    switch (inScalars->GetDataType())
+    ContourGridWorker worker(this, exExt, input, output,
+                             this->GenerateTriangles != 0);
+    typedef vtkTypeList_Create_2(float, double) OutputTypes;
+    typedef vtkTypeList_Create_2(float, double) InputTypes;
+    typedef vtkArrayDispatch::Dispatch2ByValueType<InputTypes, OutputTypes> MyDispatch;
+    vtkDataArray *pointsarray = input->GetPoints()->GetData();
+    if (!MyDispatch::Execute(inScalars, pointsarray, worker))
     {
-      vtkTemplateMacro(
-        ContourGrid(this, exExt, static_cast<VTK_TT *>(scalars), input, output, inScalars, this->GenerateTriangles!=0));
-    }//switch
+      vtkErrorMacro("Unable to calculate contour. ArrayDispatch failed.");
+    }
   }
   else //multiple components - have to convert
   {
@@ -914,8 +927,16 @@ void vtkGridSynchronizedTemplates3D::ThreadedExecute(vtkStructuredGrid *input,
     image->SetNumberOfComponents(inScalars->GetNumberOfComponents());
     image->Allocate(dataSize*image->GetNumberOfComponents());
     inScalars->GetTuples(0,dataSize,image);
-    double *scalars = image->GetPointer(0);
-    ContourGrid(this, exExt, scalars, input, output, inScalars, this->GenerateTriangles!=0);
+    ContourGridWorker worker(this, exExt, input, output,
+                             this->GenerateTriangles != 0);
+    typedef vtkTypeList_Create_2(float, double) OutputTypes;
+    typedef vtkTypeList_Create_1(double) InputTypes;
+    typedef vtkArrayDispatch::Dispatch2ByValueType<InputTypes, OutputTypes> MyDispatch;
+    vtkDataArray *pointsarray = input->GetPoints()->GetData();
+    if (!MyDispatch::Execute(image, pointsarray, worker))
+    {
+      vtkErrorMacro("Unable to calculate contour. ArrayDispatch failed.");
+    }
     image->Delete();
   }
 
diff --git a/Filters/Core/vtkRectilinearSynchronizedTemplates.cxx b/Filters/Core/vtkRectilinearSynchronizedTemplates.cxx
index b268719..7dfb7f4 100644
--- a/Filters/Core/vtkRectilinearSynchronizedTemplates.cxx
+++ b/Filters/Core/vtkRectilinearSynchronizedTemplates.cxx
@@ -274,7 +274,6 @@ void ContourRectilinearGrid(vtkRectilinearSynchronizedTemplates *self, int *exEx
   int NeedGradients = ComputeGradients || ComputeNormals;
   double n[3], n0[3], n1[3];
   int jj, g0;
-  int *tablePtr;
   int idx, vidx;
   double x[3], xz[3];
   int v0, v1, v2, v3;
@@ -586,7 +585,7 @@ void ContourRectilinearGrid(vtkRectilinearSynchronizedTemplates *self, int *exEx
             idx = idx + (*(isect2Ptr -yisectstep +4) > -1 ? 2 : 0);
             idx = idx + (*(isect2Ptr) > -1 ? 1 : 0);
 
-            tablePtr = VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_2
+            const int *tablePtr = VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_2
               + VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_1[idx];
 
             if (!outputTriangles)
diff --git a/Filters/Core/vtkSynchronizedTemplates3D.cxx b/Filters/Core/vtkSynchronizedTemplates3D.cxx
index b46e6a4..f06c481 100644
--- a/Filters/Core/vtkSynchronizedTemplates3D.cxx
+++ b/Filters/Core/vtkSynchronizedTemplates3D.cxx
@@ -280,7 +280,6 @@ void ContourImage(vtkSynchronizedTemplates3D *self, int* exExt,
   int NeedGradients = ComputeGradients || ComputeNormals;
   double n[3], n0[3], n1[3];
   vtkIdType jj, g0;
-  int *tablePtr;
   vtkIdType idx;
   int vidx;
   double x[3], xz[3];
@@ -577,7 +576,7 @@ void ContourImage(vtkSynchronizedTemplates3D *self, int* exExt,
             idx = idx + (*(isect2Ptr -yisectstep +4) > -1 ? 2 : 0);
             idx = idx + (*(isect2Ptr) > -1 ? 1 : 0);
 
-            tablePtr = VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_2
+            const int *tablePtr = VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_2
               + VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_1[idx];
 
             if (!outputTriangles)
@@ -827,7 +826,7 @@ void vtkSynchronizedTemplates3D::PrintSelf(ostream& os, vtkIndent indent)
 
 // template table.
 
-int VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_1[] = {
+const int VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_1[] = {
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  592,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
@@ -1650,7 +1649,7 @@ int VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_1[] = {
    0, 1698 };
 
 
-int VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_2[] = {
+const int VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_2[] = {
  -1,   0,   1,   2,  -1,   0,   4,   3,  -1,   3,   1,   2,
   4,   3,   2,  -1,   3,   7,   5,  -1,   0,   1,   2,   3,
   7,   5,  -1,   4,   7,   5,   0,   4,   5,  -1,   5,   1,
diff --git a/Filters/Core/vtkSynchronizedTemplates3D.h b/Filters/Core/vtkSynchronizedTemplates3D.h
index 5229efa..549a998 100644
--- a/Filters/Core/vtkSynchronizedTemplates3D.h
+++ b/Filters/Core/vtkSynchronizedTemplates3D.h
@@ -196,8 +196,8 @@ private:
 
 // template table.
 
-extern int VTKFILTERSCORE_EXPORT VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_1[];
-extern int VTKFILTERSCORE_EXPORT VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_2[];
+extern const int VTKFILTERSCORE_EXPORT VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_1[];
+extern const int VTKFILTERSCORE_EXPORT VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_2[];
 
 #endif
 
diff --git a/Filters/Core/vtkSynchronizedTemplatesCutter3D.cxx b/Filters/Core/vtkSynchronizedTemplatesCutter3D.cxx
index f89c45a..4856a26 100644
--- a/Filters/Core/vtkSynchronizedTemplatesCutter3D.cxx
+++ b/Filters/Core/vtkSynchronizedTemplatesCutter3D.cxx
@@ -142,7 +142,6 @@ void ContourImage(vtkSynchronizedTemplatesCutter3D *self, int *exExt,
   int i, j, k;
   vtkIdType zstep, yisectstep;
   vtkIdType offsets[12];
-  int *tablePtr;
   vtkIdType idx;
   int vidx;
   double x[3], xz[3];
@@ -478,7 +477,7 @@ void ContourImage(vtkSynchronizedTemplatesCutter3D *self, int *exExt,
             idx = idx + (*(isect2Ptr -yisectstep +4) > -1 ? 2 : 0);
             idx = idx + (*(isect2Ptr) > -1 ? 1 : 0);
 
-            tablePtr = VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_2
+            const int *tablePtr = VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_2
               + VTK_SYNCHRONIZED_TEMPLATES_3D_TABLE_1[idx];
 
             if (!outputTriangles)
