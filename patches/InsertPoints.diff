diff --git a/Common/Core/vtkPoints.cxx b/Common/Core/vtkPoints.cxx
index 8444899..7863be7 100644
--- a/Common/Core/vtkPoints.cxx
+++ b/Common/Core/vtkPoints.cxx
@@ -14,8 +14,11 @@
 =========================================================================*/
 #include "vtkPoints.h"
 
+#include "vtkArrayDispatch.h"
+#include "vtkAssume.h"
 #include "vtkBitArray.h"
 #include "vtkCharArray.h"
+#include "vtkDataArrayAccessor.h"
 #include "vtkDoubleArray.h"
 #include "vtkFloatArray.h"
 #include "vtkIdList.h"
@@ -201,6 +204,48 @@ unsigned long vtkPoints::GetActualMemorySize()
   return this->Data->GetActualMemorySize();
 }
 
+struct FunctionWorker {
+  vtkIdType Begin;
+  vtkIdType End;
+  int *Order;
+  FunctionWorker(vtkIdType begin, vtkIdType n, int *order) : Begin(begin), End(begin+n), Order(order) {}
+  template <typename SourceArray, typename DestinationArray>
+  void operator()(SourceArray *input, DestinationArray *output)
+  {
+    VTK_ASSUME(input->GetNumberOfComponents() == 3);
+    VTK_ASSUME(output->GetNumberOfComponents() == 3);
+    vtkDataArrayAccessor<SourceArray> src(input);
+    vtkDataArrayAccessor<DestinationArray> dest(output);
+    for (vtkIdType i = Begin; i < End; ++i)
+    {
+      vtkIdType inIdx = Order[i];
+      for(int j = 0; j<3; ++j)
+      {
+        dest.Set(i,j,src.Get(inIdx, j));
+      }
+    }
+  }
+};
+
+void vtkPoints::InsertPoints(vtkIdType dstStart, vtkIdType n, int *srcIds, vtkPoints *source)
+{
+  vtkIdType numPts = dstStart + n;
+  if(this->GetNumberOfPoints() < numPts)
+  {
+    this->SetNumberOfPoints(numPts);
+  }
+  typedef vtkTypeList_Create_2(float, double) OutputTypes;
+  typedef vtkTypeList_Create_2(float, double) InputTypes;
+  typedef vtkArrayDispatch::Dispatch2ByValueType<InputTypes, OutputTypes> Dispatch;
+  auto input = source->GetData();
+  auto output = this->GetData();
+  FunctionWorker worker(dstStart, n, srcIds);
+  if (!Dispatch::Execute(input, output, worker))
+  {
+    worker(input, output); // Use vtkDataArray API if dispatch fails.
+  }
+}
+
 void vtkPoints::PrintSelf(ostream& os, vtkIndent indent)
 {
   this->Superclass::PrintSelf(os, indent);
diff --git a/Common/Core/vtkPoints.h b/Common/Core/vtkPoints.h
index 2a0105e..ec0e627 100644
--- a/Common/Core/vtkPoints.h
+++ b/Common/Core/vtkPoints.h
@@ -169,6 +169,13 @@ public:
     { this->Data->InsertTuples(dstIds, srcIds, source->Data); }
 
   /**
+    * Copy the points indexed in srcIds from the source array to the tuple
+    * locations indexed consecutively from dstId in this array.
+    * Note that memory allocation is performed as necessary to hold the data.
+    */
+  void InsertPoints(vtkIdType dstStart, vtkIdType n,int *srcIds, vtkPoints *source);
+
+  /**
    * Copy n consecutive points starting at srcStart from the source array to
    * this array, starting at the dstStart location.
    * Note that memory allocation is performed as necessary to hold the data.
diff --git a/Common/DataModel/vtkCell.cxx b/Common/DataModel/vtkCell.cxx
index a1db284..0ba9175 100644
--- a/Common/DataModel/vtkCell.cxx
+++ b/Common/DataModel/vtkCell.cxx
@@ -22,7 +22,6 @@
 vtkCell::vtkCell()
 {
   this->Points = vtkPoints::New();
-  this->Points->SetDataTypeToDouble();
   this->PointIds = vtkIdList::New();
   // Consistent Register/Deletes (ShallowCopy uses Register.)
   this->Points->Register(this);
diff --git a/Common/DataModel/vtkHexahedron.cxx b/Common/DataModel/vtkHexahedron.cxx
index edce296..7763b05 100644
--- a/Common/DataModel/vtkHexahedron.cxx
+++ b/Common/DataModel/vtkHexahedron.cxx
@@ -353,7 +353,7 @@ static int edges[12][2] = { {0,1}, {1,2}, {3,2}, {0,3},
                             {0,4}, {1,5}, {3,7}, {2,6}};
 static int faces[6][5] = { {0,4,7,3,-1}, {1,2,6,5,-1},
                            {0,1,5,4,-1}, {3,7,6,2,-1},
-                           {0,3,2,1,-1}, {4,5,6,7,-1} };
+                           {0,3,2,1,-1}, {4,5,6,7,-1}};
 
 // Marching cubes case table
 //
@@ -472,16 +472,12 @@ int *vtkHexahedron::GetFaceArray(int faceId)
 //----------------------------------------------------------------------------
 vtkCell *vtkHexahedron::GetFace(int faceId)
 {
-  int *verts, i;
-
-  verts = faces[faceId];
-
-  for (i=0; i<4; i++)
+  int *verts = faces[faceId];
+  for (int i=0; i<4; i++)
   {
-    this->Quad->PointIds->SetId(i,this->PointIds->GetId(verts[i]));
-    this->Quad->Points->SetPoint(i,this->Points->GetPoint(verts[i]));
+    this->Quad->PointIds->SetId(i, this->PointIds->GetId(verts[i]));
   }
-
+  this->Quad->Points->InsertPoints(0, 4, verts, this->Points);
   return this->Quad;
 }
 
@@ -554,87 +550,27 @@ int vtkHexahedron::IntersectWithLine(double p1[3], double p2[3], double tol,
 //----------------------------------------------------------------------------
 int vtkHexahedron::Triangulate(int index, vtkIdList *ptIds, vtkPoints *pts)
 {
-  int p[4], i;
-
-  ptIds->Reset();
-  pts->Reset();
-
+  ptIds->SetNumberOfIds(20);
+  pts->SetNumberOfPoints(20);
+  static int p0[] = {0,1,3,4,1,4,5,6,1,4,6,3,1,3,6,2,3,6,7,4};
+  static int p1[] = {2,1,5,0,0,2,3,7,2,5,6,7,0,7,4,5,0,2,7,5};
   // Create five tetrahedron. Triangulation varies depending upon index. This
   // is necessary to insure compatible voxel triangulations.
-  if ( (index % 2) )
+  int *p = nullptr;
+  if ((index % 2))
   {
-    p[0] = 0; p[1] = 1; p[2] = 3; p[3] = 4;
-    for ( i=0; i < 4; i++ )
-    {
-      ptIds->InsertNextId(this->PointIds->GetId(p[i]));
-      pts->InsertNextPoint(this->Points->GetPoint(p[i]));
-    }
-
-    p[0] = 1; p[1] = 4; p[2] = 5; p[3] = 6;
-    for ( i=0; i < 4; i++ )
-    {
-      ptIds->InsertNextId(this->PointIds->GetId(p[i]));
-      pts->InsertNextPoint(this->Points->GetPoint(p[i]));
-    }
-
-    p[0] = 1; p[1] = 4; p[2] = 6; p[3] = 3;
-    for ( i=0; i < 4; i++ )
-    {
-      ptIds->InsertNextId(this->PointIds->GetId(p[i]));
-      pts->InsertNextPoint(this->Points->GetPoint(p[i]));
-    }
-
-    p[0] = 1; p[1] = 3; p[2] = 6; p[3] = 2;
-    for ( i=0; i < 4; i++ )
-    {
-      ptIds->InsertNextId(this->PointIds->GetId(p[i]));
-      pts->InsertNextPoint(this->Points->GetPoint(p[i]));
-    }
-
-    p[0] = 3; p[1] = 6; p[2] = 7; p[3] = 4;
-    for ( i=0; i < 4; i++ )
-    {
-      ptIds->InsertNextId(this->PointIds->GetId(p[i]));
-      pts->InsertNextPoint(this->Points->GetPoint(p[i]));
-    }
+    p = p0;
   }
   else
   {
-    p[0] = 2; p[1] = 1; p[2] = 5; p[3] = 0;
-    for ( i=0; i < 4; i++ )
-    {
-      ptIds->InsertNextId(this->PointIds->GetId(p[i]));
-      pts->InsertNextPoint(this->Points->GetPoint(p[i]));
-    }
-
-    p[0] = 0; p[1] = 2; p[2] = 3; p[3] = 7;
-    for ( i=0; i < 4; i++ )
-    {
-      ptIds->InsertNextId(this->PointIds->GetId(p[i]));
-      pts->InsertNextPoint(this->Points->GetPoint(p[i]));
-    }
-
-    p[0] = 2; p[1] = 5; p[2] = 6; p[3] = 7;
-    for ( i=0; i < 4; i++ )
-    {
-      ptIds->InsertNextId(this->PointIds->GetId(p[i]));
-      pts->InsertNextPoint(this->Points->GetPoint(p[i]));
-    }
-
-    p[0] = 0; p[1] = 7; p[2] = 4; p[3] = 5;
-    for ( i=0; i < 4; i++ )
-    {
-      ptIds->InsertNextId(this->PointIds->GetId(p[i]));
-      pts->InsertNextPoint(this->Points->GetPoint(p[i]));
-    }
+    p = p1;
+  }
 
-    p[0] = 0; p[1] = 2; p[2] = 7; p[3] = 5;
-    for ( i=0; i < 4; i++ )
-    {
-      ptIds->InsertNextId(this->PointIds->GetId(p[i]));
-      pts->InsertNextPoint(this->Points->GetPoint(p[i]));
-    }
+  for (int i=0; i < 20; ++i)
+  {
+    ptIds->SetId(i,this->PointIds->GetId(p[i]));
   }
+  pts->InsertPoints(0,20,p,this->Points);
 
   return 1;
 }
