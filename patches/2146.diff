diff --git a/Common/DataModel/vtkStructuredData.cxx b/Common/DataModel/vtkStructuredData.cxx
index 22f7f15..b4ce1e7 100644
--- a/Common/DataModel/vtkStructuredData.cxx
+++ b/Common/DataModel/vtkStructuredData.cxx
@@ -15,8 +15,10 @@
 #include "vtkStructuredData.h"
 
 #include "vtkIdList.h"
+#include "vtkMath.h"
 #include "vtkObjectFactory.h"
 #include "vtkStructuredExtent.h"
+#include <algorithm>
 #include <cassert>
 
 
@@ -359,15 +361,43 @@ void vtkStructuredData::GetPointCells(vtkIdType ptId, vtkIdList *cellIds,
   return;
 }
 
+// convert an id into a point in i-j-k space.
+// Integer division is slow and 64-bit integers are about 7x slower than 32-bit
+// integers.
+class IdToLoc {
+public:
+  IdToLoc(int dims[3]) { std::copy_n(dims, 3, dim); }
+  void operator()(vtkIdType id, int loc[3])
+  {
+#ifdef VTK_USE_64BIT_IDS
+    if (id <= UINT_MAX)
+    {
+      unsigned uid = id;
+      loc[0] = uid % dim[0];
+      loc[1] = (uid / dim[0]) % dim[1];
+      loc[2] = (uid / dim[0]) / dim[1];
+    }
+    else
+    {
+      loc[0] = id % dim[0];
+      loc[1] = (id / dim[0]) % dim[1];
+      loc[2] = (id / dim[0]) / dim[1];
+    }
+#else
+    loc[0] = id % dim[0];
+    loc[1] = (id / dim[0]) % dim[1];
+    loc[2] = (id / dim[0]) / dim[1];
+#endif
+  }
+private:
+  int dim[3];
+};
+
 //------------------------------------------------------------------------------
 void vtkStructuredData::GetCellNeighbors(vtkIdType cellId, vtkIdList *ptIds,
-                                        vtkIdList *cellIds, int dim[3])
+                                         vtkIdList *cellIds, int dim[3])
 {
-  int j, seedLoc[3], ptLoc[3], cellLoc[3];
-  vtkIdType cellDim[3];
-  int offset[8][3];
-  vtkIdType numPts = ptIds->GetNumberOfIds(), id, i;
-
+  vtkIdType numPts = ptIds->GetNumberOfIds();
   cellIds->Reset();
 
   // Start by finding the "space" of the points in i-j-k space.
@@ -376,12 +406,12 @@ void vtkStructuredData::GetCellNeighbors(vtkIdType cellId, vtkIdList *ptIds,
   // The numbers of DOF determines which neighbors to select.
 
   // Start by finding a seed point
-  id = ptIds->GetId(0);
-  seedLoc[0] = id % dim[0];
-  seedLoc[1] = (id / dim[0]) % dim[1];
-  seedLoc[2] = id / (dim[0]*dim[1]);
+  IdToLoc getLoc(dim);
+  int seedLoc[3];
+  getLoc(ptIds->GetId(0), seedLoc);
 
   // This defines the space around the seed
+  int offset[8][3];
   offset[0][0] = -1; offset[0][1] = -1; offset[0][2] = -1;
   offset[1][0] =  0; offset[1][1] = -1; offset[1][2] = -1;
   offset[2][0] = -1; offset[2][1] =  0; offset[2][2] = -1;
@@ -393,13 +423,11 @@ void vtkStructuredData::GetCellNeighbors(vtkIdType cellId, vtkIdList *ptIds,
 
   // For the rest of the points, trim the seed region
   // This is essentially an intersection of edge neighbors.
-  for (i=1; i<numPts; i++)
+  for (vtkIdType i = 1; i < numPts; i++)
   {
     //  Get the location of the point
-    id = ptIds->GetId(i);
-    ptLoc[0] = id % dim[0];
-    ptLoc[1] = (id / dim[0]) % dim[1];
-    ptLoc[2] = id / (static_cast<vtkIdType>(dim[0])*dim[1]);
+    int ptLoc[3];
+    getLoc(ptIds->GetId(i), ptLoc);
 
     if ( (ptLoc[0]-1) == seedLoc[0] )
     {
@@ -446,21 +474,16 @@ void vtkStructuredData::GetCellNeighbors(vtkIdType cellId, vtkIdList *ptIds,
   }
 
   // Load the non-trimmed cells
-  cellDim[0] = dim[0] - 1;
-  cellDim[1] = dim[1] - 1;
-  cellDim[2] = dim[2] - 1;
-
-  for(i=0; i<3; i++)
+  int cellDim[3];
+  for (int i = 0; i < 3; i++)
   {
-    if ( cellDim[i] < 1 )
-    {
-      cellDim[i] = 1;
-    }
+    cellDim[i] = vtkMath::Max(dim[i] - 1, 1);
   }
 
-  for (j=0; j<8; j++)
+  for (int j = 0; j < 8; j++)
   {
-    for (i=0; i<3; i++)
+    int i = 0, cellLoc[3];
+    for (; i < 3; i++)
     {
       if ( offset[j][i] != -10 )
       {
@@ -477,8 +500,8 @@ void vtkStructuredData::GetCellNeighbors(vtkIdType cellId, vtkIdList *ptIds,
     }
     if ( i >= 3 ) //add cell
     {
-      id = cellLoc[0] + cellLoc[1]*cellDim[0] +
-                        cellLoc[2]*cellDim[0]*cellDim[1];
+      vtkIdType id = cellLoc[0] + cellLoc[1] * cellDim[0] +
+                     cellLoc[2] * cellDim[0] * cellDim[1];
       if (id != cellId )
       {
         cellIds->InsertNextId(id);
